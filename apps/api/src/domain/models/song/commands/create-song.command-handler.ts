import { Ack, CommandHandler, ICommandHandler } from '@coscrad/commands';
import { buildSimpleValidationFunction } from '@coscrad/validation';
import { Inject } from '@nestjs/common';
import { InternalError, isInternalError } from '../../../../lib/errors/InternalError';
import { isNotAvailable } from '../../../../lib/types/not-available';
import { isNotFound, NotFound } from '../../../../lib/types/not-found';
import { isOK } from '../../../../lib/types/ok';
import { RepositoryProvider } from '../../../../persistence/repositories/repository.provider';
import { DTO } from '../../../../types/DTO';
import getInstanceFactoryForEntity from '../../../factories/getInstanceFactoryForEntity';
import { IIdManager } from '../../../interfaces/id-manager.interface';
import { ResourceType } from '../../../types/ResourceType';
import InvalidCommandPayloadTypeError from '../../shared/common-command-errors/InvalidCommandPayloadTypeError';
import { Song } from '../song.entity';
import { CreateSong } from './create-song.command';
import { SongCreated } from './song-created.event';

@CommandHandler(CreateSong)
export class CreateSongCommandHandler implements ICommandHandler {
    constructor(
        private readonly repositoryProvider: RepositoryProvider,
        @Inject('ID_MANAGER') private readonly idManager: IIdManager
    ) {}

    async execute(command: CreateSong): Promise<Ack | InternalError> {
        // Validate command type
        const payloadTypeErrors = buildSimpleValidationFunction(
            Object.getPrototypeOf(command).constructor
        )(command).map(
            (simpleError) => new InternalError(`invalid payload type: ${simpleError.toString()}`)
        );

        if (payloadTypeErrors.length > 0) {
            return new InvalidCommandPayloadTypeError('CREATE_SONG', payloadTypeErrors);
        }

        // Validate external state
        const { id } = command;

        const existingSongWithTheId = await this.repositoryProvider
            .forResource<Song>(ResourceType.song)
            .fetchById(id);

        if (isInternalError(existingSongWithTheId)) {
            throw new InternalError(`Encountered an error when fetching song: ${id}`);
        }

        if (existingSongWithTheId !== NotFound) {
            return new InternalError(`There is already a song with ID: ${id}`);
        }

        // Validate that new ID was generated by our system and is available
        const idStatus = await this.idManager.status(id);

        if (isNotFound(idStatus))
            return new InternalError(
                `The id: ${id} has not been generated by our ID generation system.`
            );

        if (isNotAvailable(idStatus))
            return new InternalError(
                `The id: ${id} is already in use by another resource in our system.`
            );

        if (!isOK(idStatus)) {
            // This is out of an abundance of caution. We shouldn't hit this.
            throw new InternalError(`Unrecognized status for id: ${String(idStatus)}`);
        }

        const songDTO: DTO<Song> = {
            ...command,
            published: false,
            startMilliseconds: 0,
            type: ResourceType.song,
            eventHistory: [],
        };

        // Attempt state mutation - Result or Error (Invariant violation in our case- could also be invalid state transition in other cases)
        const instanceToPersist = getInstanceFactoryForEntity<Song>(ResourceType.song)(songDTO);

        // Does this violate invariants?
        if (isInternalError(instanceToPersist)) {
            return instanceToPersist;
        }

        // generate a unique ID for the event
        const eventId = await this.idManager.generate();

        const instanceToPersistWithUpdatedEventHistory = instanceToPersist.addEventToHistory(
            new SongCreated(command, eventId)
        );

        // Persist the valid instance
        await this.repositoryProvider
            .forResource<Song>(ResourceType.song)
            .create(instanceToPersistWithUpdatedEventHistory);

        return Ack;
    }
}
